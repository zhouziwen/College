package com.zhiyou.colleageapp.db;

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteStatement;
import android.text.TextUtils;

import com.zhiyou.colleageapp.constants.DBKey;
import com.zhiyou.colleageapp.domain.InviteMessage;
import com.zhiyou.colleageapp.eenum.InviteMsgStatus;
import com.zhiyou.colleageapp.manager.DBManager;

import java.util.List;
import java.util.Locale;

import de.greenrobot.dao.AbstractDao;
import de.greenrobot.dao.Property;
import de.greenrobot.dao.internal.DaoConfig;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.

/**
 * DAO for table "INVITE_MESSAGE".
 */
public class InviteMessageDao extends AbstractDao<InviteMessage, String> {

    public static final String TABLENAME = "INVITE_MESSAGE";

    /**
     * Properties of entity InviteMessage.<br/>
     * Can be used for QueryBuilder and for referencing column names.
     */
    public static class Properties {
        public final static Property MsgId = new Property(0, String.class, "mMsgId", true, "MSG_ID");
        public final static Property GroupId = new Property(1, String.class, "mGroupId", false, "GROUP_ID");
        public final static Property GroupName = new Property(2, String.class, "mGroupName", false, "GROUP_NAME");
        public final static Property Reason = new Property(3, String.class, "mReason", false, "REASON");
        public final static Property MsgStatus = new Property(4, String.class, "mMsgStatus", false, "MSG_STATUS");
        public final static Property IsInviteFromMe = new Property(5, Boolean.class, "mIsInviteFromMe", false, "IS_INVITE_FROM_ME");
        public final static Property MsgUnreadCount = new Property(6, Integer.class, "mMsgUnreadCount", false, "MSG_UNREAD_COUNT");
        public final static Property TimeStamp = new Property(7, Long.class, "mTimeStamp", false, "TIME_STAMP");
        public final static Property InviterId = new Property(8, String.class, "mInviteeId", false, "INVITEE_ID");
        public final static Property FromName = new Property(9, String.class, "mFromName", false, "FROM_NAME");
    }
    public InviteMessageDao(DaoConfig config) {
        super(config);
    }

    public InviteMessageDao(DaoConfig config, DaoSession daoSession) {
        super(config, daoSession);
    }
    /**
     * Creates the underlying database table.
     */
    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
        String constraint = ifNotExists ? "IF NOT EXISTS " : "";
        db.execSQL("CREATE TABLE " + constraint + "\"INVITE_MESSAGE\" (" + //
                "\"MSG_ID\" TEXT PRIMARY KEY ," + // 0: GroupId
                "\"GROUP_ID\" TEXT ," + // 1: MsgId
                "\"GROUP_NAME\" TEXT," + // 2: GroupName
                "\"REASON\" TEXT," + // 3: Reason
                "\"MSG_STATUS\" TEXT," + // 4: MsgStatus
                "\"IS_INVITE_FROM_ME\" INTEGER," + // 5: IsInviteFromMe
                "\"MSG_UNREAD_COUNT\" INTEGER," + // 6: MsgUnreadCount
                "\"TIME_STAMP\" INTEGER," + // 7: TimeStamp
                "\"INVITEE_ID\" TEXT," +// 8: InviterId
                "\"FROM_NAME\" TEXT);"); // 9: From
    }

    /**
     * Drops the underlying database table.
     */
    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "\"INVITE_MESSAGE\"";
        db.execSQL(sql);
    }

    /**
     * @inheritdoc
     */
    @Override
    protected void bindValues(SQLiteStatement stmt, InviteMessage entity) {
        stmt.clearBindings();
        String MsgId = entity.getMsgId();
        if (MsgId != null) {
            stmt.bindString(1, MsgId);
        }

        String GroupId = entity.getGroupId();
        if (GroupId != null) {
            stmt.bindString(2, GroupId);
        }

        String GroupName = entity.getGroupName();
        if (GroupName != null) {
            stmt.bindString(3, GroupName);
        }

        String reason = entity.getReason();
        if (reason != null) {
            stmt.bindString(4, reason);
        }

        InviteMsgStatus status = entity.getMsgStatus();
        if (status != null) {
            stmt.bindString(5, status.name());
        }

        Boolean IsInviteFromMe = entity.getIsInviteFromMe();
        if (IsInviteFromMe != null) {
            stmt.bindLong(6, IsInviteFromMe ? 1L : 0L);
        }

        Integer MsgUnreadCount = entity.getMsgUnreadCount();
        if (MsgUnreadCount != null) {
            stmt.bindLong(7, MsgUnreadCount);
        }

        Long TimeStamp = entity.getTimeStamp();
        if (TimeStamp != null) {
            stmt.bindLong(8, TimeStamp);
        }

        String inviteeId = entity.getInviteeId();
        if (!TextUtils.isEmpty(inviteeId)) {
            stmt.bindString(9, inviteeId);
        }

        String from = entity.getFrom();
        if (from != null) {
            stmt.bindString(10, from);
        }
    }

    /**
     * @inheritdoc
     */
    @Override
    public String readKey(Cursor cursor, int offset) {
        return cursor.isNull(offset) ? null : cursor.getString(offset);
    }

    /**
     * @inheritdoc
     */
    @Override
    public InviteMessage readEntity(Cursor cursor, int offset) {
        InviteMessage entity = new InviteMessage();
        readEntity(cursor, entity, offset);
        return entity;
    }

    /**
     * @inheritdoc
     */
    @Override
    public void readEntity(Cursor cursor, InviteMessage entity, int offset) {
        entity.setMsgId(cursor.isNull(offset) ? null : cursor.getString(offset));
        entity.setGroupId(cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1));
        entity.setGroupName(cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2));
        entity.setReason(cursor.isNull(offset + 3) ? null : cursor.getString(offset + 3));
        entity.setMsgStatus(cursor.isNull(offset + 4) ? null : InviteMsgStatus.valueOf(cursor.getString(offset + 4)));
        entity.setIsInviteFromMe(cursor.isNull(offset + 5) ? null : cursor.getShort(offset + 5) != 0);
        entity.setMsgUnreadCount(cursor.isNull(offset + 6) ? null : cursor.getInt(offset + 6));
        entity.setTimeStamp(cursor.isNull(offset + 7) ? null : cursor.getLong(offset + 7));
        entity.setInviteeId(cursor.isNull(offset + 8) ? null : cursor.getString(offset + 8));
        entity.setFrom(cursor.isNull(offset + 9) ? null : cursor.getString(offset + 9));
    }

    /**
     * @inheritdoc
     */
    @Override
    protected String updateKeyAfterInsert(InviteMessage entity, long rowId) {
        return entity.getMsgId();
    }

    /**
     * @inheritdoc
     */
    @Override
    public String getKey(InviteMessage entity) {
        if (entity != null) {
            return entity.getMsgId();
        } else {
            return null;
        }
    }

    /**
     * @inheritdoc
     */
    @Override
    protected boolean isEntityUpdateable() {
        return true;
    }


    public void deleteByFromName(String fromUserName) {
        String sql = String.format("DELETE FROM %s WHERE %s = ?", TABLENAME, DBKey.FROM_NAME);

        DBManager.getInstance().getDb().execSQL(sql, new Object[]{fromUserName});
    }


    public int getUnreadMessagesCount() {
        int count = 0;
        String sql = String.format(Locale.getDefault(), "SELECT %s FROM %s WHERE %s > ?", DBKey.INVITE_UN_READ_COUNT, TABLENAME, DBKey.INVITE_UN_READ_COUNT);
        SQLiteDatabase db = getDatabase();
        Cursor cursor = db.rawQuery(sql, new String[]{"0"});
        if (cursor != null) {
            while (cursor.moveToNext()) {
                count += cursor.getInt(cursor.getColumnIndex(DBKey.INVITE_UN_READ_COUNT));
            }
            cursor.close();
        }
        return count;
    }


    public void updateInviteMessage(InviteMessage msg) {
        if (msg == null) {
            return;
        }
        insertOrReplaceInTx(msg);
    }

    public void markAllInviteMsgAsRead() {
        String sql = String.format(Locale.getDefault(), "SELECT * FROM %s WHERE %s > ?",TABLENAME, DBKey.INVITE_UN_READ_COUNT);
        SQLiteDatabase db = getDatabase();
        Cursor cursor = db.rawQuery(sql, new String[]{"0"});
        if (cursor != null) {
            List<InviteMessage> list = loadAllFromCursor(cursor);
            for (InviteMessage msg : list
                    ) {
                msg.setMsgUnreadCount(0);
            }
            updateInTx(list);
            cursor.close();
        }
    }

}
